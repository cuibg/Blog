待完成
学习NSScanner
NSOperation
masnory（函数式编程）
http://blog.csdn.net/colorapp/article/details/45030163
http://draveness.me/ios-yuan-dai-ma-fen-xi-masonry/
计算机网络
算法 快速排序 反转单链表 链表 顺序表 写出 O(1) 空间复杂度 O(n) 时间复杂度的程序
method swiing
项目管理 
团队管理
http://wdxtub.com/about/

http://www.henishuo.com/ios-needgo-interview/
http://onevcat.com/2016/02/swift-performance/
http://weibo.com/ttarticle/p/show?id=2309403946563633331671
http://www.henishuo.com/ios-middle-interview-questions-one/

1、__weak 和 __block 区别
https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html
* 所属范畴不同
前者属于ARC内存管理，后者属于GCD

* 作用不用
前者用于声明弱引用对象，后者用于声明在 GCD block 内外均可修改的局部变量

* 说明
__block 声明的变量在 MRC 下出现在 block 内时不会 retain 对象，但在 MRC 下会

2、Hex string to UIColor

```
// Assumes input like "#00FF00" (#RRGGBB).
+ (UIColor *)colorFromHexString:(NSString *)hexString {
    unsigned rgbValue = 0;
    NSScanner *scanner = [NSScanner scannerWithString:hexString];
    [scanner setScanLocation:1]; // bypass '#' character
    [scanner scanHexInt:&rgbValue];
    return [UIColor colorWithRed:((rgbValue & 0xFF0000) >> 16)/255.0 green:((rgbValue & 0xFF00) >> 8)/255.0 blue:(rgbValue & 0xFF)/255.0 alpha:1.0];
}
```

3、autolayout 原理
AutoLayout的原理是在layoutSubviews中应用Constraints来设置View的frame。换句话说，Constraints只是一个在layoutSubviews时执行的任务队列。

4、计算机程序是如何运行的
http://www.cnblogs.com/zuoxiaolong/archive/2013/09/20/computer1.html

五、NSOperation

1、 启动线程

创建 NSOperation 的子类（NSInvocationOperation、NSBlockOperation或者自定义子类）的实例后，NSOperation 对应任务的执行线程为：

* 主线程
 
①没有重写 start 方法，通过调用 start 方法启动任务，会在 `当前` 线程执行；

②将 NSOperation 对象添加到通过 [NSOperationQueue mainQueue] 方式创建的 NSOperationQueue 中，会在 main 线程执行；

* 其它线程

①重写 start 方法时，可以指定任务的执行线程(AFURLConnectionOperation)；

②将 NSOperation 对象添加到通过 [[NSOperationQueue alloc] init] 方式创建的 NSOperationQueue 中，会在其它线程执行；

2、依赖关系

NSOperation 之间可以设置依赖关系

3、NSOperation继承

除了直接使用 NSInvocationOperation 和 NSBlockOperation 外，自己子类化 NSOperation 的时候通常只需要重写 main 方法即可，但记得加 autorelease pool。

并发的 NSOperation 子类需要重写 start 方法。

4、Operation管理

NSOperationQueue 可以对最大并发数目进行约束；
NSOperationQueue 可以挂起 operation queue，但正在执行的任务会继续执行；
NSOperationQueue 可以取消 queue 中的所有 operation，但正在执行的任务会继续执行；

六、多线程技术

1、NSThread
优点：较轻量
缺点：需要自己管理线程的生命周期，线程同步，线程之间的依赖关系；

2、NSOperation/NSOperationQueue（对GCD的封装）
优点：
不需关心线程的事，可以把注意力集中在任务本身；
NSOperation 可以很方便的设置依赖，NSOperationQueue 可以很方便的管理并发；
任务状态可以通过 KVO/KVC 监听

以下情况会选择NSOperation：
任务之间有依赖关系
限制最大可执行的任务数量
任务可能被取消

缺点：

3、GCD
优点：
简单易用
针对多核处理器（iPhone4s A5以上）优化，任务都在并行执行的线程池中执行。
可以很方便的进行任务嵌套

缺点：
不支持 KVO/KVC
原生不支持取消（也可以通过不端检查 bool 标志，如果为 YES 就提前返回实现）

4、performSelector

七、GCD

1、循环提交一个任务

```
func dispatch_apply(_ iterations: UInt,  执行的次数
                  _ queue: dispatch_queue_t!,  
                  _ block: ((UInt) -> Void)!)  
```

2、延迟执行一个任务

```
func dispatch_after(_ when: dispatch_time_t,  
                  _ queue: dispatch_queue_t!,  
                  _ block: dispatch_block_t!) 
```

3、阻塞当前queue

```
func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):
```

最典型的使用场景是读写问题（Getter/Setter方法）：

```
- (void)setObject:(id)anObject forKey:(id<NSCopying>)aKey
{
    dispatch_barrier_async(self.concurrentQueue, ^{
        [self.mutableDictionary setObject:anObject forKey:aKey];
    });
}

- (id)objectForKey:(id)aKey
{
    __block id object = nil;
    dispatch_sync(self.concurrentQueue, ^{
        object = [self.mutableDictionary objectForKey:aKey];
    });
    return  object;
}
```

对于自己创建的并发的 queue，在它之后提交的任务需要在它之前提交的任务都执行完了，且自己的 block 任务也执行完了以后，才能执行；
非自己创建的并发 queue（串行或者 global 并行 queue） 调用该法的时候，等价于  dispatch_async。

该方法调用后会立即返回，还有一个 sync 的方法：

```
dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block);
```

该方法调用后不会立即返回，而是等待 queue 中在其之前提交的任务都执行了以后，其本身绑定的任务也执行了，才会继续执行其后提交的任务。也就是说，其后提交的任务在其执行完毕之前都还没被提交到 queue 中。

4、信号量

对应有三个方法：

```
dispatch_semaphore_t  dispatch_semaphore_create(long value);
long dispatch_semaphore_signal(dispatch_semaphore_t dsema) // 信号量加一
long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)； // 信号连减一
```
需要在非主线程中用上述方法；
只有信号量大于0的时候，才能继续执行，否则会挂起线程。

八、@synthesize和@dynamic的异同
两个关键字都是针对 property 声明的属性的：

1、@synthesize
告诉编译器帮忙生成 setter/getter 方法
可以指定对应的实例变量

2、@dynamic
用于当前类没有实现 property 的 setter/getter 方法时，告诉编译器不要自动生成 setter/getter方法，也不要发出警告，对应的 setter/getter 方法会在运行时动态生成或者已经在父类实现。

目前 @synthesize 属性均已没什么用处了，最新的 Xcode 会默认生成  setter/getter方法。

九、32位和64位的区别

指针类型(char*)由 32 位变成 64 位，对应的寻址空间也变了。

![image](https://github.com/wangzz/Blog/blob/master/image/%E9%A2%98%E7%9B%AE/32:63bit.png)

十、进程和线程

1、进程是系统分配资源的最小单位，线程是任务调度的最小单位
2、一个程序至少有一个进程，一个进程至少有一个线程
3、进程之间的内存空间相互独立，线程可以共享其所在进程的内存空间(包括代码段、数据集、堆等)
4、二者均可并发执行

十一、同步和互斥

互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。　　

同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

十二、static关键字

用该关键字声明的函数或变量，仅在当前文件有效。
static 变量既不存在栈上也不存在堆上，而是保存在静态存储区

十三、虚拟内存

1、进程虚拟内存布局

每个进程内存布局都一样，寻址空间也都一样，和系统位数保持一致。

![virtualmemory](https://github.com/wangzz/Blog/blob/master/image/%E9%A2%98%E7%9B%AE/virtualmemory.png)
![virtualmemory2](https://github.com/wangzz/Blog/blob/master/image/%E9%A2%98%E7%9B%AE/virtualmemory2.png)

2、虚拟内存

* 虚拟内存可以不用管物理内存的实际大小，让寻址空间和计算机位数保持一致
* 虚拟内存可以让每一个进程的内存结构都一样，寻址空间都一样，大大简化了程序员编程的复杂逻辑
* 虚拟内存可以通过内存交换，在物理内存紧张时将一部分数据交换到磁盘上
* 虚拟内存地址可以是连续的，但其对应的物理内存地址却不一定是连续的，这提高了物理内存的利用率

3、栈和堆的区别

①管理方式：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露。

②生长方向：栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。

③空间大小：栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。

④存储内容：栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。

⑤分配方式：栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。

⑥分配效率：栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。

⑦分配后系统响应：只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。

操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。

此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。

⑧碎片问题：栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。

可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。

使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果。

